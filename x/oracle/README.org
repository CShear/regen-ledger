#+TITLE: Group Module
*STATUS: In Process* 

#+BEGIN_SRC go :tangle types.go :exports none
  /* GENERATED FROM README.org
     DO NOT EDIT THIS FILE DIRECTLY!!!!! */
  package oracle

  import (
    sdk "github.com/cosmos/cosmos-sdk/types"
	  "math/big"
  )
#+END_SRC

* Overview

* Motivation
  
* Schemas

** Compute Function
#+BEGIN_SRC turtle
PREFIX : <http://schema.regen.network>
<xrn:graph/sghj38sdgh358>
  a :dockerComputeFunction ;
  :dockerImage "example.com/preprocess-sentinel:0.1@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2" ;
  :inputSchema [
    # input schema
  ] ;
  :outputSchema [
    # output schema
  ] ;
  :artifactSchema [
    # artifact schema for bundle of raw files generated by the compute function
  ] .
#+END_SRC

#+BEGIN_SRC json
{
  "type":"sparqlConstructFunction",
  "sparqlConstruct":"SPARQL CONSTRUCT { } ....",
  "inputSchema":{ }, // a graph that can be passed in as urn:input
  "inputParams":{ }, // parameters that can be passed in as $x, $y, etc.
  "outputSchema":{ }, // the schema of the output graph
}
#+END_SRC

#+BEGIN_SRC json
{
  "type":"sparqlAskFunction",
  "sparqlConstruct":"SPARQL ASK ....",
  "inputSchema":{ }, // a graph that can be passed in as urn:input
  "inputParams":{ }, // parameters that can be passed in as $x, $y, etc.
}
#+END_SRC
** Compute Request
#+BEGIN_SRC json
  {
    "type":"computeRequest",
    "function":"xrn:graph/38sdgh125",
    "input":"xrn:graph/2sdgh2nsdg",
    "blockHeight":135628, // the block height which the computation had access to the ledger at
  }
#+END_SRC

** Compute Result
#+BEGIN_SRC json
  {
    "type":"computeResult",
    "input":"xrn:graph/2sdgh2nsdg",
    "blockHeight":135628, // the block height which the computation had access to the ledger at
    "output":"xrn:graph/38sdgh125",
    "artifacts":"xrn:graph/sdgh1278adsf",
    "dependencies":"xrn:graph/asf21847asf" // points to a graph of dependencies this compute function saw in its execution
  }
#+END_SRC

* Transaction Messages and Types
#+BEGIN_SRC go :tangle types.go
  type MsgCommitResult struct {
    // The argon2 salted hash of the result, TODO specify parameters
	  Request OracleRequestID
    Hash []bytes `json:"bytes"`
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

#+BEGIN_SRC go :tangle types.go
  type MsgShareResult struct {
	  Request OracleRequestID
    Result data.DataAddress `json:"result"`
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

#+BEGIN_SRC go :tangle types.go
  type MsgCreateOraclePool struct {
    Oracles []sdk.AccAddress `json:"oracles"`
    Signer sdk.AccAddress `json:"signer"`
  }

  type OraclePoolID []byte

  type OracleProtocol struct {
    Oracles []sdk.AccAddress `json:"oracles"`
    MinOracles int
    MinBondAmount sdk.Coins // can be 0 for trusted 3rd party
    Arbiter sdk.AccAddress
  }

  type OraclePoolContract struct {
    OracleProtocol OracleProtocolID
    Function data.DataAddress
    MinFee sdk.Coins // can be 0 if all payments are off-chain
	  // TODO timeouts
  }
  type OraclePoolContractID []byte

  type MsgCreateOraclePoolContract struct {
  }

  type MsgAcceptOraclePoolContract struct {
    Contract OraclePoolContractID
    Oracle sdk.AccAddres
  }

  type MsgPostBond struct {
    Oracle sdk.AccAddres
    Amount sdk.Coins
  }

  type MsgUnbond struct {
    Oracle sdk.AccAddres
    Amount sdk.Coins
  }

  type MsgRequestCompute struct {
    Contract OraclePoolContractID
    Input data.DataAddress
    Fee sdk.Coins
  }
#+END_SRC
  
* Identifiers

* Indexing and Queries

* Rationale
  
* Consensus Protocol
** Function Invocation
** Function Invocation Request
** Oracle Pool Contract
** Execution Results
** Round Structure
*** Select Oracle
When a compute function invocation is requested against an oracle pool, the first oracle to run the contract is chosen at
random based on the result of the block hash in which the request is transacted. Given an array of ~N~ oracles in an
oracle pool we select the array of the ~M~ oracles which have not been elected to compute this function invocation yet,
maintaining the original array order and call this resulting array the selection pool. The selected oracle is the ~i~'th
oracle in the selection pool array where $i = blockHash \bmod{M}$. A tag alerting the oracle that it has been
selected for this round may be attached to the next block or this information may simply stored in the appropriate index (TODO).
*** Commit Result
    Once the selected oracle has completed the requested computation 
#+BEGIN_SRC go :tangle types.go
  type MsgCommitResult struct {
	  // The argon2 salted hash of the result, TODO specify parameters
    Hash []bytes `json:"bytes"`
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC
**** Handling Timeouts
The oracle pool contract for the given function will include a timeout window. If the selected oracle cannot complete the
result in the specified timeout window, it should post a heartbeat message before the timeout block and TODO.
If the selected oracle fails to commit a result at all before the end of the timeout window, another oracle will be chosen
at random and the original selection oracle will be marked as unavailable and scheduled for its bond to be slashed accordingly,
unless, of course, all requested oracles timeout in which the curator of the function will be slashed for improper function
implementation.
*** Select Next Oracle or Finish Commit
*** Share Results
*** Vote
#+BEGIN_SRC go :tangle types.go
  type MsgVoteResult struct {
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC
*** Consensus, Resolution Round or Failure
